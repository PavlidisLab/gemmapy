<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gemmapy.gemmapy_api &#8212; GemmaPy 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=fcb5b4b3" />
    <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for gemmapy.gemmapy_api</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Gemma python API (https://gemma.msl.ubc.ca/rest/v2/)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span>   <span class="nn">gemmapy</span> <span class="kn">import</span> <span class="n">sdk</span>
<span class="kn">from</span> <span class="nn">gemmapy</span> <span class="kn">import</span> <span class="n">processors</span> <span class="k">as</span> <span class="n">ps</span>
<span class="kn">from</span> <span class="nn">gemmapy</span> <span class="kn">import</span> <span class="n">validators</span> <span class="k">as</span> <span class="n">vs</span>
<span class="kn">from</span> <span class="nn">gemmapy</span> <span class="kn">import</span> <span class="n">subprocessors</span> <span class="k">as</span> <span class="n">sub</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span><span class="n">Union</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">from</span> <span class="nn">anndata</span> <span class="kn">import</span> <span class="n">AnnData</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">json</span>


<div class="viewcode-block" id="GemmaPy">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy">[docs]</a>
<span class="k">class</span> <span class="nc">GemmaPy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main API class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auth</span><span class="p">:</span><span class="nb">list</span><span class="o">|</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;prod&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list auth: (optional) A list or tuple of credential strings, e.g.</span>
<span class="sd">          (your_username, your_password)</span>
<span class="sd">        :param bool devel: (optional) If True development version of Gemma API will be</span>
<span class="sd">          used. Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">configuration</span> <span class="o">=</span> <span class="n">sdk</span><span class="o">.</span><span class="n">Configuration</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># configuration.host = &#39;https://gemma.msl.ubc.ca/rest/v2&#39;</span>
        <span class="k">elif</span> <span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;dev&#39;</span><span class="p">:</span>
            <span class="n">configuration</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;https://dev.gemma.msl.ubc.ca/rest/v2&#39;</span>
        <span class="k">elif</span> <span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;staging&#39;</span><span class="p">:</span>
            <span class="n">configuration</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="s2">&quot;https://staging-gemma.msl.ubc.ca/rest/v2&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">configuration</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="n">path</span>
        

        <span class="k">if</span> <span class="n">auth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">configuration</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">auth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">configuration</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="n">auth</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create an instance of the API class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">sdk</span><span class="o">.</span><span class="n">DefaultApi</span><span class="p">(</span><span class="n">sdk</span><span class="o">.</span><span class="n">ApiClient</span><span class="p">(</span><span class="n">configuration</span><span class="p">))</span>


    <span class="c1"># /resultSets/count get_number_of_result_sets ------</span>
    <span class="c1"># unimplemented</span>
    <span class="c1"># we don&#39;t need this here, not included</span>
    
    <span class="c1"># /resultSets/{resultSet}</span>
    <span class="c1"># this was only used in the past to access result set metadata by </span>
    <span class="c1"># using a hidden parameter. this information can be accessed using get_result_sets</span>
    <span class="c1"># enpoint instead</span>
    
    <span class="c1"># /resultSets/{resultSet_}, get_result_set_as_tsv ------ </span>
    <span class="c1"># made internal to not cause unneeded confusion</span>
    <span class="c1"># use get_differential_expression_values instead</span>
    <span class="k">def</span> <span class="nf">__get_result_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_set</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param result_set: DESCRIPTION</span>
<span class="sd">        :type result_set: int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_result_set_as_tsv</span>
<span class="sd">        :return: DESCRIPTION</span>
<span class="sd">        :rtype: TYPE</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_result_set_as_tsv</span><span class="p">(</span><span class="n">result_set</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_de_matrix</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">result_set</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span>
        

    
    <span class="c1"># /resultSets, get_result_sets -----</span>
    
<div class="viewcode-block" id="GemmaPy.get_result_sets">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_result_sets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_result_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">datasets</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">result_sets</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="nb">filter</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">offset</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                        <span class="n">sort</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;+id&quot;</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns queried result set</span>

<span class="sd">        Output and usage of this function is mostly identical to </span>
<span class="sd">        get_dataset_differential_expression_analyses. The principal difference</span>
<span class="sd">        being the ability to restrict your result sets, being able to query </span>
<span class="sd">        across multiple datasets and being able to use the filter argument to </span>
<span class="sd">        search based on result set properties.</span>


<span class="sd">        </span>
<span class="sd">        :param datasets: A numerical dataset identifier or a dataset short name, defaults to None</span>
<span class="sd">        :type datasets: Optional[List[str|int]], optional</span>
<span class="sd">        :param result_sets: 	A result set identifier. Note that result set identifiers are not static and can change when Gemma re-runs analyses internally. Whem using these as inputs, try to make sure you access a currently existing result set ID by basing them on result sets returned for a particular dataset or filter used in get_result_sets, defaults to None</span>
<span class="sd">        :type result_sets: Optional[List[int]], optional</span>
<span class="sd">        :param filter: Filter results by matching expression. Use </span>
<span class="sd">          filter_properties function to get a list of all available parameters. </span>
<span class="sd">          These properties can be combined using &quot;and&quot; &quot;or&quot; clauses and may </span>
<span class="sd">          contain common operators such as &quot;=&quot;, &quot;&lt;&quot; or &quot;in&quot;. (e.g. </span>
<span class="sd">          &quot;taxon.commonName = human&quot;, &quot;taxon.commonName in (human,mouse), </span>
<span class="sd">          &quot;id &lt; 1000&quot;), defaults to None</span>
<span class="sd">        :type filter: str, optional</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param sort: Order results by the given property and direction. The &#39;+&#39;</span>
<span class="sd">          sign indicate ascending order whereas the &#39;-&#39; indicate descending,</span>
<span class="sd">          defaults to &quot;+id&quot;</span>
<span class="sd">        :type sort: str, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_result_sets</span>
<span class="sd">        :return: A DataFrame with information about the queried result sets. </span>
<span class="sd">          Note that this function does not return differential expression values</span>
<span class="sd">          themselves</span>
<span class="sd">        </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - result_ID: Result set ID of the differential expression analysis. May represent multiple factors in a single model.</span>
<span class="sd">            - contrast_ID: Id of the specific contrast factor. Together with the result.ID they uniquely represent a given contrast.</span>
<span class="sd">            - experiment_ID: Id of the source experiment</span>
<span class="sd">            - factor_category: Category for the contrast</span>
<span class="sd">            - factor_category_URI: URI for the baseline category</span>
<span class="sd">            - factor_ID: ID of the factor</span>
<span class="sd">            - baseline_factors: Characteristics of the baseline. This field is a DataFrame</span>
<span class="sd">            - experimental_factors: Characteristics of the experimental group. This field is a DataFrame</span>
<span class="sd">            - is_subset: True if the result set belong to a subset, False if not. Subsets are created when performing differential expression to avoid unhelpful comparisons.</span>
<span class="sd">            - subset_factor: Characteristics of the subset. This field is a DataFrame</span>
<span class="sd">        </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">result_sets</span><span class="p">)</span>
        
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">,</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">,</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_result_sets</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_DifferentialExpressionAnalysisResultSetValueObject</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">df</span></div>


    
    <span class="c1"># /annotations/search, search_annotations --------</span>
<div class="viewcode-block" id="GemmaPy.search_annotations">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.search_annotations">[docs]</a>
    <span class="k">def</span> <span class="nf">search_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for annotation tags</span>


<span class="sd">        :param query: The search query</span>
<span class="sd">        :type query: List[str]</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.search_annotations</span>
<span class="sd">        :return: A DataFrame with annotations matching the given identifiers. </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - category_name: Category that the annotation belongs to</span>
<span class="sd">            - category_URI: URI for the category_name</span>
<span class="sd">            - value_name: Annotation term</span>
<span class="sd">            - value_URI: URI for the value_name</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">search_annotations</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_search_annotations</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    

    <span class="c1"># /datasets/{dataset}/annotations, get_dataset_annotations ----------</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_annotations">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_annotations">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the annotations of a dataset</span>


<span class="sd">        :param dataset: 	A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: str|int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_annotations</span>
<span class="sd">        :return: A DataFrame with information about the annotations of the queried dataset. </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - class_name: Name of the annotation class (e.g. organism part)</span>
<span class="sd">            - class_URI: URI for the annotation class</span>
<span class="sd">            - term_name: Name of the annotation term (e.g. lung)</span>
<span class="sd">            - term_URI: URI for the annotation term</span>
<span class="sd">            - object_class: Class of object that the term originated from.       </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_annotations</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_annotations</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="n">df</span></div>

    
    <span class="c1"># /datasets/{dataset}/design, get_dataset_design -----</span>
    <span class="c1"># this endpoint is not very useful since the names it comes with</span>
    <span class="c1"># is annoying to match names provided in the samples endpoint</span>
    <span class="c1"># make_design replaces this</span>
    <span class="k">def</span> <span class="nf">__get_dataset_design</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: DESCRIPTION</span>
<span class="sd">        :type dataset: str|int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_design</span>
<span class="sd">        :type **kwargs: TYPE</span>
<span class="sd">        :return: DESCRIPTION</span>
<span class="sd">        :rtype: TYPE</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_design</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_dataset_design</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span>
    
    <span class="c1"># /datasets/{datasets}/expressions/differential ------</span>
    <span class="c1"># unimplemented</span>
    <span class="c1"># not sure how the parameters for this endpoint works and doesn&#39;t seem essential</span>
    
    <span class="c1"># /datasets/{dataset}/analyses/differential, get_dataset_differential_expression_analyses ------</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_differential_expression_analyses">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_differential_expression_analyses">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_differential_expression_analyses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                                     <span class="n">dataset</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve annotations and surface level stats for a dataset&#39;s differential analyses</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: str|int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_differential_expression_analyses</span>
<span class="sd">        :return: A data table with information about the differential expression</span>
<span class="sd">          analysis of the queried dataset. Note that this funciton does not return </span>
<span class="sd">          differential expression values themselves. Use</span>
<span class="sd">          get_differential_expression_values to get differential expression</span>
<span class="sd">          values (see examples).</span>
<span class="sd">          </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - result_ID: Result set ID of the differential expression analysis. May represent multiple factors in a single model.</span>
<span class="sd">            - contrast_ID: Id of the specific contrast factor. Together with the result.ID they uniquely represent a given contrast.</span>
<span class="sd">            - experiment_ID: Id of the source experiment</span>
<span class="sd">            - factor_category: Category for the contrast</span>
<span class="sd">            - factor_category_URI: URI for the contrast category</span>
<span class="sd">            - factor_ID: ID of the factor</span>
<span class="sd">            - baseline_factors: Characteristics of the baseline. This field is a DataFrame</span>
<span class="sd">            - experimental_factors: Characteristics of the experimental group. This field is a DataFrame</span>
<span class="sd">            - isSubset: True if the result set belong to a subset, False if not. </span>
<span class="sd">              Subsets are created when performing differential expression to avoid </span>
<span class="sd">              unhelpful comparisons.</span>
<span class="sd">            - subset_factor: Characteristics of the subset. This field is a DataFrame</span>
<span class="sd">            - probes_analyzed: Number of probesets represented in the contrast</span>
<span class="sd">            - genes_analyzed: Number of genes represented in the contrast</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_differential_expression_analyses</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span>
                                                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_dea</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span></div>

    
    <span class="c1"># /datasets/{dataset}/analyses/differential/resultSets -----</span>
    <span class="c1"># unimplemented</span>
    <span class="c1"># unsure about the distinction between this and the get_dataset_differential_expression_analyses. </span>
    <span class="c1"># seem to contain the reduntant information</span>
    
    
    <span class="c1"># /datasets/{dataset}/data -----</span>
    <span class="c1"># deprecated, remove later</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_expression">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_expression">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated in favour of get_dataset_expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;get_dataset_expression is deprecated, please use get_dataset_processed_expression instead&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_processed_expression</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    
    
    
    <span class="c1"># /datasets/{datasets}/expressions/genes/{genes}, get_dataset_expression_for_genes ------</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_expression_for_genes">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_expression_for_genes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_expression_for_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">datasets</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">],</span>
                                         <span class="n">genes</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                         <span class="n">keep_non_specific</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                         <span class="n">consolidate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">:</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the expression data matrix of a set of datasets and genes</span>


<span class="sd">        :param datasets: A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type datasets: List[str|int]</span>
<span class="sd">        :param genes: An ensembl gene identifier which typically starts with </span>
<span class="sd">          ensg or an ncbi gene identifier or an official gene symbol approved by </span>
<span class="sd">          hgnc</span>
<span class="sd">        :type genes: List[int]</span>
<span class="sd">        :param keep_non_specific: If True, results from probesets that are not</span>
<span class="sd">          specific to the gene will also be returned., defaults to False</span>
<span class="sd">        :type keep_non_specific: bool, optional</span>
<span class="sd">        :param consolidate: An option for gene expression level consolidation. </span>
<span class="sd">          If empty, will return every probe for the genes. &quot;pickmax&quot; to pick the</span>
<span class="sd">          probe with the highest expression, &quot;pickvar&quot; to pick the prove with the </span>
<span class="sd">          highest variance and &quot;average&quot; for returning the average expression, </span>
<span class="sd">          defaults to None</span>
<span class="sd">        :type consolidate: TYPE, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_expression_for_genes</span>
<span class="sd">        :return: A dict of DataFrames keyed to dataset ids</span>
<span class="sd">        :rtype: dict[int:DataFrame]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span>
            <span class="n">keep_non_specific</span> <span class="o">=</span> <span class="n">keep_non_specific</span><span class="p">,</span>
            <span class="n">consolidate</span> <span class="o">=</span> <span class="n">consolidate</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_expression_for_genes</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">genes</span><span class="p">,</span> 
                                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_dataset_gene_expression</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span></div>

        
    <span class="c1"># datasets/{datasets}/expressions/pca -----</span>
    <span class="c1"># unimplemented</span>
    
    
    <span class="c1"># datasets/{dataset}/platforms ------</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_platforms">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_platforms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_platforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: str|int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_platforms</span>
<span class="sd">        :return: A DataFrame with information about the platforms.</span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">                </span>
<span class="sd">            - platform_ID: Id number of the platform given by Gemma</span>
<span class="sd">            - platform_type: Type of the platform.</span>
<span class="sd">            - platform_description: Free text field describing the platform.</span>
<span class="sd">            - platform_troubled: Whether the platform is marked as troubled by a Gemma curator.</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underlying database used in Gemma for the taxon  </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_platforms</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_platforms</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        
        <span class="k">return</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

    
    
    <span class="c1"># datasets/{dataset}/data/processed ------</span>
    
<div class="viewcode-block" id="GemmaPy.get_dataset_processed_expression">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_processed_expression">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_processed_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dataset</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve processed expression data of a dataset</span>

<span class="sd">        </span>
<span class="sd">        :param dataset:  numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: str|int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_processed_expression</span>
<span class="sd">        :return: A DataFrame of the expression matrix for the queried dataset</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_processed_expression</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_expression</span><span class="p">(</span><span class="n">response</span><span class="p">,</span><span class="n">dataset</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span></div>

    
    <span class="c1"># datasets/{dataset}/quantitationTypes get_dataset_quantitation_types ----------</span>
    
<div class="viewcode-block" id="GemmaPy.get_dataset_quantitation_types">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_quantitation_types">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_quantitation_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dataset</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve quantitation types of a dataset</span>

<span class="sd">        </span>
<span class="sd">        :param dataset: 	A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: int|str</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_quantitation_types</span>
<span class="sd">        :return: A DataFrame containing the quantitation types</span>
<span class="sd">        </span>
<span class="sd">          The fields of the output DataFrame are:</span>
<span class="sd">            - id: If of the quantitation type. Any raw quantitation type can be</span>
<span class="sd">               by get_dataset_raw_expression function using this id.</span>
<span class="sd">            - name: Name of the quantitation type</span>
<span class="sd">            - description: Description of the quantitation type</span>
<span class="sd">            - type: Type of the quantitation type. Either raw or processed. </span>
<span class="sd">              Each dataset will have one processed quantitation type which is the </span>
<span class="sd">              data returned using get_dataset_processed_expression</span>
<span class="sd">            - ratio: Whether or not the quanitation type is a ratio of multiple</span>
<span class="sd">              quantitation types. Typically TRUE for processed TWOCOLOR quantitation type.</span>
<span class="sd">            - preferred: The preferred raw quantitation type. This version is </span>
<span class="sd">              used in generation of the processed data within gemma.</span>
<span class="sd">            - recomputed: If TRUE this quantitation type is generated by</span>
<span class="sd">              recomputing raw data files Gemma had access to</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_quantitation_types</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_QuantitationTypeValueObject</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        
        
        <span class="k">return</span> <span class="n">df</span></div>


    <span class="c1"># datasets/{dataset}/data/raw, get_dataset_raw_expression ---------</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_raw_expression">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_raw_expression">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_raw_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dataset</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
                                   <span class="n">quantitation_type</span><span class="p">:[</span><span class="nb">int</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: int|str</span>
<span class="sd">        :param quantitation_type: Quantitation type id. These can be acquired </span>
<span class="sd">          using get_dataset_quantitation_types function. This endpoint can only </span>
<span class="sd">          return non-processed quantitation types.</span>
<span class="sd">        :type quantitation_type: [int]</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_raw_expression</span>
<span class="sd">        :return: A DataFrame of the expression matrix for the queried dataset</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span>
            <span class="n">quantitation_type</span> <span class="o">=</span> <span class="n">quantitation_type</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_raw_expression</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_expression</span><span class="p">(</span><span class="n">response</span><span class="p">,</span><span class="n">dataset</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span></div>

    
    
    <span class="c1"># datasets/{dataset}/samples, get_dataset_samples --------</span>
<div class="viewcode-block" id="GemmaPy.get_dataset_samples">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_samples">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the samples of a dataset</span>


<span class="sd">        :param dataset: A numerical dataset identifier or a dataset short name</span>
<span class="sd">        :type dataset: int|str</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_dataset_samples</span>
<span class="sd">        :return: A DataFrame with information about the samples of the queried dataset.</span>
<span class="sd">        </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - sample_name: Internal name given to the sample.</span>
<span class="sd">            - sample_ID: Internal ID of the sample</span>
<span class="sd">            - sample_description: Free text description of the sample</span>
<span class="sd">            - sample_outlier: Whether or not the sample is marked as an outlier</span>
<span class="sd">            - sample_accession: Accession ID of the sample in it&#39;s original database</span>
<span class="sd">            - sample_database: Database of origin for the sample</span>
<span class="sd">            - sample_characteristics: Characteristics of the sample. This field is a data table</span>
<span class="sd">            - sample_factor_values: Experimental factor values of the sample. This field is a data table</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_dataset_samples</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_samples</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

        
    <span class="c1"># datasets/{dataset}/svd --- </span>
    <span class="c1"># not implemented</span>
    
    <span class="c1"># datasets, get_datasets ------</span>
<div class="viewcode-block" id="GemmaPy.get_datasets">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_datasets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">query</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="nb">filter</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">taxa</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">uris</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">offset</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                     <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                     <span class="n">sort</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;+id&quot;</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param query: The search query. Either plain text (&#39;traumatic&#39;), or an </span>
<span class="sd">          ontology term URI (&#39;http://purl.obolibrary.org/obo/UBERON_0002048&#39;).</span>
<span class="sd">          Datasets that contain the given string in their short of full name will </span>
<span class="sd">          also be matched., defaults to None</span>
<span class="sd">        :type query: Optional[str], optional</span>
<span class="sd">        :param filter: Filter results by matching expression. Use </span>
<span class="sd">          filter_properties function to get a list of all available parameters. </span>
<span class="sd">          These properties can be combined using &quot;and&quot; &quot;or&quot; clauses and may </span>
<span class="sd">          contain common operators such as &quot;=&quot;, &quot;&lt;&quot; or &quot;in&quot;. (e.g. </span>
<span class="sd">          &quot;taxon.commonName = human&quot;, &quot;taxon.commonName in (human,mouse), </span>
<span class="sd">          &quot;id &lt; 1000&quot;), defaults to None</span>
<span class="sd">        :type filter: Optional[str], optional</span>
<span class="sd">        :param taxa: A vector of taxon common names (e.g. human, mouse, rat).</span>
<span class="sd">          Providing multiple species will return results for all species. These </span>
<span class="sd">          are appended to the filter and equivalent to filtering for </span>
<span class="sd">          taxon.commonName property, defaults to None</span>
<span class="sd">        :param taxa: A list of taxon common names (e.g. human, mouse, rat). </span>
<span class="sd">          Providing multiple species will return results for all species. </span>
<span class="sd">          These are appended to the filter and equivalent to filtering for </span>
<span class="sd">          taxon.commonName property, defaults to None</span>
<span class="sd">        :type taxa: Optional[List[str]], optional</span>
<span class="sd">        :param uris: A vector of ontology term URIs. Providing multiple terms</span>
<span class="sd">          will return results containing any of the terms and their children. </span>
<span class="sd">          These are appended to the filter and equivalent to filtering for </span>
<span class="sd">          allCharacteristics.valueUri, defaults to None</span>
<span class="sd">        :type uris: Optional[List[str]], optional</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param sort: Order results by the given property and direction. The &#39;+&#39;</span>
<span class="sd">          sign indicate ascending order whereas the &#39;-&#39; indicate descending,</span>
<span class="sd">          defaults to &quot;+id&quot;</span>
<span class="sd">        :type sort: str, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_datasets</span>
<span class="sd">        :return: A DataFrame with information about the queried dataset(s).</span>
<span class="sd">        </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - experiment_short_name: Shortname given to the dataset within Gemma. Often corresponds to accession ID</span>
<span class="sd">            - experiment_name: Full title of the dataset</span>
<span class="sd">            - experiment_ID: Internal ID of the dataset.</span>
<span class="sd">            - experiment_description: Description of the dataset</span>
<span class="sd">            - experiment_troubled: Did an automatic process within gemma or a curator mark the dataset as &quot;troubled&quot;</span>
<span class="sd">            - experiment_accession: Accession ID of the dataset in the external database it was taken from</span>
<span class="sd">            - experiment_database: The name of the database where the dataset was taken from</span>
<span class="sd">            - experiment_URI: URI of the original database</span>
<span class="sd">            - experiment_sample_count: Number of samples in the dataset</span>
<span class="sd">            - experiment_batch_effect: A text field describing whether the dataset has batch effects</span>
<span class="sd">            - geeq.batch_corrected: Whether batch correction has been performed on the dataset.</span>
<span class="sd">            - geeq.batch_confound: 0 if batch info isn&#39;t available, -1 if batch counfoud is detected, 1 if batch information is available and no batch confound found</span>
<span class="sd">            - geeq.batch_effect: -1 if batch p value &lt; 0.0001, 1 if batch p value &gt; 0.1, 0 if otherwise and when there is no batch information is available or when the data is confounded with batches.</span>
<span class="sd">            - geeq_raw_data: -1 if no raw data available, 1 if raw data was available. When available, Gemma reprocesses raw data to get expression values and batches</span>
<span class="sd">            - geeq_q_score: Data quality score given to the dataset by Gemma.</span>
<span class="sd">            - geeq.s_score: Suitability score given to the dataset by Gemma. Refers to factors like batches, platforms and other aspects of experimental design</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underyling database used in Gemma for the taxon</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="s1">&#39;allCharacteristics.valueUri&#39;</span><span class="p">,</span> <span class="n">uris</span><span class="p">)</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="s1">&#39;taxon.commonName&#39;</span><span class="p">,</span> <span class="n">taxa</span><span class="p">)</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="p">,</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">,</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_datasets</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_datasets</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

        
        <span class="k">return</span> <span class="n">df</span></div>

    
    <span class="c1"># datasets/annotations -----</span>
    <span class="c1"># currently unimplemented</span>
    
    
    <span class="c1"># datasets/{datasets}, get_datasets_by_ids -----</span>
<div class="viewcode-block" id="GemmaPy.get_datasets_by_ids">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_datasets_by_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">get_datasets_by_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">],</span>
                            <span class="nb">filter</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">taxa</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">uris</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">offset</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                            <span class="n">sort</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;+id&quot;</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param dataset: Numerical dataset identifiers or dataset short names.</span>
<span class="sd">        :type dataset: List[str|int]</span>
<span class="sd">        :param filter: Filter results by matching expression. Use </span>
<span class="sd">          filter_properties function to get a list of all available parameters. </span>
<span class="sd">          These properties can be combined using &quot;and&quot; &quot;or&quot; clauses and may </span>
<span class="sd">          contain common operators such as &quot;=&quot;, &quot;&lt;&quot; or &quot;in&quot;. (e.g. </span>
<span class="sd">          &quot;taxon.commonName = human&quot;, &quot;taxon.commonName in (human,mouse), </span>
<span class="sd">          &quot;id &lt; 1000&quot;), defaults to None</span>
<span class="sd">        :type filter: Optional[str], optional</span>
<span class="sd">        :param taxa: A list of taxon common names (e.g. human, mouse, rat). </span>
<span class="sd">          Providing multiple species will return results for all species. </span>
<span class="sd">          These are appended to the filter and equivalent to filtering for </span>
<span class="sd">          taxon.commonName property, defaults to None</span>
<span class="sd">        :type taxa: Optional[List[str]], optional</span>
<span class="sd">        :param uris: A vector of ontology term URIs. Providing multiple terms</span>
<span class="sd">          will return results containing any of the terms and their children. </span>
<span class="sd">          These are appended to the filter and equivalent to filtering for </span>
<span class="sd">          allCharacteristics.valueUri, defaults to None</span>
<span class="sd">        :type uris: Optional[List[str]], optional</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param sort: Order results by the given property and direction. The &#39;+&#39;</span>
<span class="sd">          sign indicate ascending order whereas the &#39;-&#39; indicate descending,</span>
<span class="sd">          defaults to &quot;+id&quot;</span>
<span class="sd">        :type sort: str, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_datasets_by_ids</span>
<span class="sd">        :return: A DataFrame with information about the queried dataset(s).</span>
<span class="sd">        </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - experiment_short_name: Shortname given to the dataset within Gemma. Often corresponds to accession ID</span>
<span class="sd">            - experiment_name: Full title of the dataset</span>
<span class="sd">            - experiment_ID: Internal ID of the dataset.</span>
<span class="sd">            - experiment_description: Description of the dataset</span>
<span class="sd">            - experiment_troubled: Did an automatic process within gemma or a curator mark the dataset as &quot;troubled&quot;</span>
<span class="sd">            - experiment_accession: Accession ID of the dataset in the external database it was taken from</span>
<span class="sd">            - experiment_database: The name of the database where the dataset was taken from</span>
<span class="sd">            - experiment_URI: URI of the original database</span>
<span class="sd">            - experiment_sample_count: Number of samples in the dataset</span>
<span class="sd">            - experiment_batch_effect: A text field describing whether the dataset has batch effects</span>
<span class="sd">            - geeq.batch_corrected: Whether batch correction has been performed on the dataset.</span>
<span class="sd">            - geeq.batch_confound: 0 if batch info isn&#39;t available, -1 if batch counfoud is detected, 1 if batch information is available and no batch confound found</span>
<span class="sd">            - geeq.batch_effect: -1 if batch p value &lt; 0.0001, 1 if batch p value &gt; 0.1, 0 if otherwise and when there is no batch information is available or when the data is confounded with batches.</span>
<span class="sd">            - geeq_raw_data: -1 if no raw data available, 1 if raw data was available. When available, Gemma reprocesses raw data to get expression values and batches</span>
<span class="sd">            - geeq_q_score: Data quality score given to the dataset by Gemma.</span>
<span class="sd">            - geeq.s_score: Suitability score given to the dataset by Gemma. Refers to factors like batches, platforms and other aspects of experimental design</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underyling database used in Gemma for the taxon</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="s1">&#39;allCharacteristics.valueUri&#39;</span><span class="p">,</span> <span class="n">uris</span><span class="p">)</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="s1">&#39;taxon.commonName&#39;</span><span class="p">,</span> <span class="n">taxa</span><span class="p">)</span>
        
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">,</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_datasets_by_ids</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_datasets</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="n">df</span></div>


    <span class="c1"># datasets/categories -----</span>
    <span class="c1"># currently unimplemented</span>

    <span class="c1"># datasets/taxa -----</span>
    <span class="c1"># currently unimplemented</span>

    <span class="c1"># datasets/count -----</span>
    <span class="c1"># currently unimplemented</span>

    <span class="c1"># genes/{gene}/goTerms -------   </span>
    
<div class="viewcode-block" id="GemmaPy.get_gene_go_terms">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_gene_go_terms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_gene_go_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param gene: An ensembl gene identifier which typically starts with </span>
<span class="sd">          ensg or an ncbi gene identifier or an official gene symbol approved by</span>
<span class="sd">          hgnc</span>
<span class="sd">        :type gene: str|int</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_gene_go_terms</span>
<span class="sd">        :return: A DataFrame with information about the GO terms assigned to the queried gene</span>
<span class="sd">          The fields of the output DataFrame are:</span>
<span class="sd">            - term_name: Name of the term</span>
<span class="sd">            - term_ID: ID of the term</span>
<span class="sd">            - term_URI: URI of the term </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_gene_go_terms</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_GO</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>


    
    <span class="c1"># genes/{gene}/locations, get_gene_locations ----</span>
    
<div class="viewcode-block" id="GemmaPy.get_gene_locations">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_gene_locations">[docs]</a>
    <span class="k">def</span> <span class="nf">get_gene_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param gene: DESCRIPTION</span>
<span class="sd">        :type gene: str|int</span>
<span class="sd">        :param **kwargs: DAdditional arguments to pass to raw.get_gene_locations</span>
<span class="sd">        :type **kwargs: TYPE</span>
<span class="sd">        :return: A DataFrame with information about the physical location of the queried gene</span>
<span class="sd">          The fields of the output DataFrame are:</span>
<span class="sd">            - chromosome: Name of the chromosome the gene is located</span>
<span class="sd">            - strand: Which strand the gene is located</span>
<span class="sd">            - nucleotide: Nucleotide number for the gene</span>
<span class="sd">            - length: Gene length</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underlying database used in Gemma for the taxon      </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_gene_locations</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_gene_location</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

    
    <span class="c1"># genes/{gene}/probes, get_gene_probes -----</span>
    
<div class="viewcode-block" id="GemmaPy.get_gene_probes">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_gene_probes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_gene_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">offset</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the probes associated to a genes across all platforms</span>
<span class="sd">        </span>
<span class="sd">        :param gene: An ensembl gene identifier which typically starts with</span>
<span class="sd">          ensg or an ncbi gene identifier or an official gene symbol approved by </span>
<span class="sd">          hgnc</span>
<span class="sd">        :type gene: str|int</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_gene_probes</span>
<span class="sd">        :return: A DataFrame with information about the probes representing a </span>
<span class="sd">          gene across all platrofms.</span>
<span class="sd">        </span>
<span class="sd">          The fields of the output DataFrame are:</span>
<span class="sd">            - element_name: Name of the element. Typically the probeset name</span>
<span class="sd">            - element_description: A free text field providing optional information about the element</span>
<span class="sd">            - platform_short_name: Shortname of the platform given by Gemma. Typically the GPL identifier.</span>
<span class="sd">            - platform_name: Full name of the platform</span>
<span class="sd">            - platform_ID: Id number of the platform given by Gemma</span>
<span class="sd">            - platform_type: Type of the platform.</span>
<span class="sd">            - platform_description: Free text field describing the platform.</span>
<span class="sd">            - platform_troubled: Whether the platform is marked as troubled by a Gemma curator.</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underlying database used in Gemma for the taxon    </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                 <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_gene_probes</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_elements</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">df</span></div>

        
        
    <span class="c1"># genes/{genes}, get_genes-------</span>

<div class="viewcode-block" id="GemmaPy.get_genes">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_genes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genes</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve genes matching gene identifiers</span>

<span class="sd">        :param genes: An ensembl gene identifier which typically starts with </span>
<span class="sd">          ensg or an ncbi gene identifier or an official gene symbol approved by hgnc</span>
<span class="sd">        :type genes: int|str</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw_get_genes</span>
<span class="sd">        :return: A DataFrame with the information about the querried genes.</span>
<span class="sd">        </span>
<span class="sd">          The fields of the output DataFrame are:</span>
<span class="sd">            - gene_symbol: Symbol for the gene</span>
<span class="sd">            - gene_ensembl: Ensembl ID for the gene</span>
<span class="sd">            - gene_NCBI: NCBI id for the gene</span>
<span class="sd">            - gene_name: Name of the gene</span>
<span class="sd">            - gene_aliases: Gene aliases. Each row includes a vector</span>
<span class="sd">            - gene_MFX_rank: Multifunctionality rank for the gene</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underlying database used in Gemma for the taxon    </span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_genes</span><span class="p">(</span><span class="n">genes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_genes</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>


    <span class="c1"># platforms/count -----</span>
    <span class="c1"># unimplemented</span>
    
    <span class="c1"># platform/{platform}/annotations -----</span>
    <span class="c1"># in gemma.R this endpoint isn&#39;t implemented and uses a convenience function instead</span>
    <span class="c1"># here we just use the enpoint since the added functionality isn&#39;t needed</span>

    <span class="c1"># Corresponding gemma.R function doesn&#39;t use any endpoint (uses some alternative URL</span>
    <span class="c1"># to get info) but has several options allowing to select the ann. type:</span>
    <span class="c1"># annotType = c(&quot;bioProcess&quot;, &quot;noParents&quot;, &quot;allParents&quot;)</span>
    <span class="c1"># This feature is not implemented here, the return value corresponds to &quot;noParents&quot;</span>
    <span class="c1"># (as of 2022-05-19)</span>
<div class="viewcode-block" id="GemmaPy.get_platform_annotations">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_platform_annotations">[docs]</a>
    <span class="k">def</span> <span class="nf">get_platform_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets Gemma&#39;s platform annotations including mappings of microarray probes to genes.</span>
<span class="sd">        </span>
<span class="sd">        :param platform: A platform numerical identifier or a platform short name</span>
<span class="sd">        :type platform: int|str</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_platform_annotations</span>
<span class="sd">        :type **kwargs: TYPE</span>
<span class="sd">        :return: A DataFrame of annotations</span>
<span class="sd">        </span>
<span class="sd">          - ProbeName: Probeset names provided by the platform. Gene symbols for generic annotations</span>
<span class="sd">          - GeneSymbols: Genes that were found to be aligned to the probe sequence. Note that it is possible for probes to be non-specific. Alignment to multiple genes are indicated with gene symbols separated by &quot;|&quot;s</span>
<span class="sd">          - GeneNames: Name of the gene</span>
<span class="sd">          - GOTerms: GO Terms associated with the genes. annotType argument can be used to choose which terms should be included.</span>
<span class="sd">          - GemmaIDs and NCBIids: respective IDs for the genes.</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">api_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_platform_annotations</span><span class="p">(</span><span class="n">platform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">uncomment</span> <span class="o">=</span> <span class="n">api_response</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">)</span>
        <span class="n">api_response</span> <span class="o">=</span> <span class="n">uncomment</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">uncomment</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">uncomment</span> <span class="o">=</span> <span class="n">api_response</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">api_response</span> <span class="o">=</span> <span class="n">uncomment</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">uncomment</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">api_response</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span></div>


    <span class="c1"># platform/{platform}/datasets, get_platform_datasets ----</span>

<div class="viewcode-block" id="GemmaPy.get_platform_datasets">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_platform_datasets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_platform_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span>
                              <span class="n">offset</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve all experiments using a given platform</span>

<span class="sd">        </span>
<span class="sd">        :param platform: A platform numerical identifier or a platform short name</span>
<span class="sd">        :type platform: str|int</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_platform_datasets</span>
<span class="sd">        :return: A DataFrame with information about the queried dataset(s).</span>
<span class="sd">        </span>
<span class="sd">          The fields of the DataFrame are:</span>
<span class="sd">            - experiment_short_name: Shortname given to the dataset within Gemma. Often corresponds to accession ID</span>
<span class="sd">            - experiment_name: Full title of the dataset</span>
<span class="sd">            - experiment_ID: Internal ID of the dataset.</span>
<span class="sd">            - experiment_description: Description of the dataset</span>
<span class="sd">            - experiment_troubled: Did an automatic process within gemma or a curator mark the dataset as &quot;troubled&quot;</span>
<span class="sd">            - experiment_accession: Accession ID of the dataset in the external database it was taken from</span>
<span class="sd">            - experiment_database: The name of the database where the dataset was taken from</span>
<span class="sd">            - experiment_URI: URI of the original database</span>
<span class="sd">            - experiment_sample_count: Number of samples in the dataset</span>
<span class="sd">            - experiment_batch_effect: A text field describing whether the dataset has batch effects</span>
<span class="sd">            - geeq.batch_corrected: Whether batch correction has been performed on the dataset.</span>
<span class="sd">            - geeq.batch_confound: 0 if batch info isn&#39;t available, -1 if batch counfoud is detected, 1 if batch information is available and no batch confound found</span>
<span class="sd">            - geeq.batch_effect: -1 if batch p value &lt; 0.0001, 1 if batch p value &gt; 0.1, 0 if otherwise and when there is no batch information is available or when the data is confounded with batches.</span>
<span class="sd">            - geeq_raw_data: -1 if no raw data available, 1 if raw data was available. When available, Gemma reprocesses raw data to get expression values and batches</span>
<span class="sd">            - geeq_q_score: Data quality score given to the dataset by Gemma.</span>
<span class="sd">            - geeq.s_score: Suitability score given to the dataset by Gemma. Refers to factors like batches, platforms and other aspects of experimental design</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underyling database used in Gemma for the taxon</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                 <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_platform_datasets</span><span class="p">(</span><span class="n">platform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_datasets</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">df</span></div>


    <span class="c1"># platforms/{platform}/elements/{probes} -----</span>
    <span class="c1"># not implemented</span>
    
    <span class="c1"># platforms/{platform}/elements/{probe}/genes, get_platform_element_genes ----</span>

<div class="viewcode-block" id="GemmaPy.get_platform_element_genes">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_platform_element_genes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_platform_element_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span> 
                                   <span class="n">probe</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">,</span>
                                   <span class="n">offset</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                   <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the genes associated to a probe in a given platform</span>
<span class="sd">        </span>
<span class="sd">        :param platform: A platform numerical identifier or a platform short name</span>
<span class="sd">        :type platform: str|int</span>
<span class="sd">        :param probe: A probe name or it&#39;s numerical identifier</span>
<span class="sd">        :type probe: str|int</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to pass to raw.get_platform_element_genes</span>
<span class="sd">        :type **kwargs: TYPE</span>
<span class="sd">        :return: A DataFrame with the information about querried gene(s).</span>
<span class="sd">          The fields of the output DataFrame are:</span>
<span class="sd">            - gene_symbol: Symbol for the gene</span>
<span class="sd">            - gene_ensembl: Ensembl ID for the gene</span>
<span class="sd">            - gene_NCBI: NCBI id for the gene</span>
<span class="sd">            - gene_name: Name of the gene</span>
<span class="sd">            - gene_aliases: Gene aliases. Each row includes a vector</span>
<span class="sd">            - gene_MFX_rank: Multifunctionality rank for the gene</span>
<span class="sd">            - taxon_name: Name of the species</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underlying database used in Gemma for the taxon</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                 <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_platform_element_genes</span><span class="p">(</span><span class="n">platform</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_genes</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">df</span></div>

    <span class="c1"># platforms/{platform}/elements ----</span>
    <span class="c1"># unimplemented</span>
    <span class="c1"># reduntant with annotation files</span>

    <span class="c1"># platforms get_platforms -----</span>
    <span class="c1"># unimplemented in R but easier to keep things separate here</span>
<div class="viewcode-block" id="GemmaPy.get_platforms">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_platforms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_platforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="nb">filter</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">taxa</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">offset</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                      <span class="n">sort</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;+id&quot;</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve all platforms</span>
<span class="sd">        </span>
<span class="sd">        :param filter: Filter results by matching expression. Use </span>
<span class="sd">          filter_properties function to get a list of all available parameters.</span>
<span class="sd">          These properties can be combined using &quot;and&quot; &quot;or&quot; clauses and may </span>
<span class="sd">          contain common operators such as &quot;=&quot;, &quot;&lt;&quot; or &quot;in&quot;. (e.g. </span>
<span class="sd">          &quot;taxon.commonName = human&quot;, &quot;taxon.commonName in (human,mouse), </span>
<span class="sd">          &quot;id &lt; 1000&quot;), defaults to None</span>
<span class="sd">        :type filter: str, optional</span>
<span class="sd">        :param taxa: A list of taxon common names (e.g. human, mouse, rat). </span>
<span class="sd">          Providing multiple species will return results for all species. These </span>
<span class="sd">          are appended to the filter and equivalent to filtering for </span>
<span class="sd">          taxon.commonName property, defaults to None</span>
<span class="sd">        :type taxa: List[str], optional</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param sort: Order results by the given property and direction. The &#39;+&#39;</span>
<span class="sd">          sign indicate ascending order whereas the &#39;-&#39; indicate descending,</span>
<span class="sd">          defaults to &quot;+id&quot;</span>
<span class="sd">        :type sort: str, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to raw.get_platforms_by_ids</span>
<span class="sd">        :return: A DataFrame with information about the platform(s).</span>
<span class="sd">        </span>
<span class="sd">          The fields of the output DataFrame are:</span>

<span class="sd">            - platform_ID: Internal identifier of the platform</span>
<span class="sd">            - platform_short_name: Shortname of the platform.</span>
<span class="sd">            - platform_name: Full name of the platform.</span>
<span class="sd">            - platform_description: Free text description of the platform</span>
<span class="sd">            - platform_troubled: Whether or not the platform was marked &quot;troubled&quot; by a Gemma process or a curator</span>
<span class="sd">            - platform_experiment_count: Number of experiments using the platform within Gemma</span>
<span class="sd">            - platform_type: Technology type for the platform.</span>
<span class="sd">            - taxon_name: Name of the species platform was made for</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underyling database used in Gemma for the taxon</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span><span class="s2">&quot;taxon.commonName&quot;</span><span class="p">,</span><span class="n">taxa</span><span class="p">)</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span><span class="nb">filter</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">,</span>
                                 <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                 <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_platforms</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_platforms</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">df</span></div>


    <span class="c1"># platforms/{platform}, get_platforms_by_ids ---- </span>
<div class="viewcode-block" id="GemmaPy.get_platforms_by_ids">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_platforms_by_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">get_platforms_by_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">platforms</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">],</span> 
                             <span class="nb">filter</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">taxa</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">offset</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                             <span class="n">sort</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;+id&quot;</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">   </span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve platforms by their identifiers</span>

<span class="sd">        </span>
<span class="sd">        :param platforms: Platform numerical identifiers or platform short names.</span>
<span class="sd">        :type platforms: List[str|int]</span>
<span class="sd">        :param filter: Filter results by matching expression. Use </span>
<span class="sd">          filter_properties function to get a list of all available parameters.</span>
<span class="sd">          These properties can be combined using &quot;and&quot; &quot;or&quot; clauses and may </span>
<span class="sd">          contain common operators such as &quot;=&quot;, &quot;&lt;&quot; or &quot;in&quot;. (e.g. </span>
<span class="sd">          &quot;taxon.commonName = human&quot;, &quot;taxon.commonName in (human,mouse), </span>
<span class="sd">          &quot;id &lt; 1000&quot;), defaults to None</span>
<span class="sd">        :type filter: str, optional</span>
<span class="sd">        :param taxa: A list of taxon common names (e.g. human, mouse, rat). </span>
<span class="sd">          Providing multiple species will return results for all species. These </span>
<span class="sd">          are appended to the filter and equivalent to filtering for </span>
<span class="sd">          taxon.commonName property, defaults to None</span>
<span class="sd">        :type taxa: List[str], optional</span>
<span class="sd">        :param offset: The offset of the first retrieved result., defaults to 0</span>
<span class="sd">        :type offset: int, optional</span>
<span class="sd">        :param limit: Limits the result to specified amount of objects.</span>
<span class="sd">          Has a maximum value of 100. Use together with offset and the </span>
<span class="sd">          total_elements attribute in the output to compile all data if needed.</span>
<span class="sd">          Alternatively get_all_pages function can be used with all functions</span>
<span class="sd">          including offset and limit parameters, defaults to 20</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param sort: Order results by the given property and direction. The &#39;+&#39;</span>
<span class="sd">          sign indicate ascending order whereas the &#39;-&#39; indicate descending,</span>
<span class="sd">          defaults to &quot;+id&quot;</span>
<span class="sd">        :type sort: str, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to raw.get_platforms_by_ids</span>
<span class="sd">        :return: A DataFrame with information about the platform(s).</span>
<span class="sd">        </span>
<span class="sd">          The fields of the output DataFrame are:</span>

<span class="sd">            - platform_ID: Internal identifier of the platform</span>
<span class="sd">            - platform_short_name: Shortname of the platform.</span>
<span class="sd">            - platform_name: Full name of the platform.</span>
<span class="sd">            - platform_description: Free text description of the platform</span>
<span class="sd">            - platform_troubled: Whether or not the platform was marked &quot;troubled&quot; by a Gemma process or a curator</span>
<span class="sd">            - platform_experiment_count: Number of experiments using the platform within Gemma</span>
<span class="sd">            - platform_type: Technology type for the platform.</span>
<span class="sd">            - taxon_name: Name of the species platform was made for</span>
<span class="sd">            - taxon_scientific: Scientific name for the taxon</span>
<span class="sd">            - taxon_ID: Internal identifier given to the species by Gemma</span>
<span class="sd">            - taxon_NCBI: NCBI ID of the taxon</span>
<span class="sd">            - taxon_database_name: Underlying database used in Gemma for the taxon</span>
<span class="sd">            - taxon_database_ID: ID of the underyling database used in Gemma for the taxon</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">add_to_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span><span class="s2">&quot;taxon.commonName&quot;</span><span class="p">,</span><span class="n">taxa</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span><span class="nb">filter</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">,</span>
                                 <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                 <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_platforms_by_ids</span><span class="p">(</span><span class="n">platforms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_platforms</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">attach_attributes</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">df</span></div>

    
    
    <span class="c1"># search search ------</span>
    <span class="c1"># this enpdoint is not very useful when specific endpoints exist for specific</span>
    <span class="c1"># result types. keeping here for now for compatibility with R</span>
    
<div class="viewcode-block" id="GemmaPy.search_gemma">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.search_gemma">[docs]</a>
    <span class="k">def</span> <span class="nf">search_gemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">query</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span>
                     <span class="n">taxon</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">platform</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">limit</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                     <span class="n">result_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;experiment&quot;</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="p">[</span><span class="n">sdk</span><span class="o">.</span><span class="n">SearchResultValueObjectObject</span><span class="p">]:</span>

<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search everything in Gemma</span>
<span class="sd">        </span>
<span class="sd">        :param query: The search query. Either plain text (&#39;traumatic&#39;), or an </span>
<span class="sd">          ontology term URI (&#39;http://purl.obolibrary.org/obo/UBERON_0002048&#39;).</span>
<span class="sd">          Datasets that contain the given string in their short of full name</span>
<span class="sd">          will also be matched. Can be multiple identifiers separated by commas.</span>
<span class="sd">        :type query: str</span>
<span class="sd">        :param taxon: A numerical taxon identifier or an ncbi taxon identifier</span>
<span class="sd">          or a taxon identifier that matches either its scientific or common</span>
<span class="sd">          name, defaults to None</span>
<span class="sd">        :type taxon: Optional[str|int], optional</span>
<span class="sd">        :param platform: A platform numerical identifier or a platform short </span>
<span class="sd">          name, defaults to None</span>
<span class="sd">        :type platform: Optional[str|int], optional</span>
<span class="sd">        :param limit: Defaults to 100 with a maximum value of 2000. Limits the</span>
<span class="sd">          number of returned results. Note that this function does not support</span>
<span class="sd">          pagination., defaults to 100</span>
<span class="sd">        :type limit: int, optional</span>
<span class="sd">        :param result_type: The kind of results that should be included in the</span>
<span class="sd">          output. Can be &quot;experiment&quot;, &quot;gene&quot;, &quot;platform&quot; or a long object type name,</span>
<span class="sd">          documented in the API documentation., defaults to &quot;experiment&quot;</span>
<span class="sd">        :type result_type: str, optional</span>
<span class="sd">        :param **kwargs: Additional arguments to raw.search</span>
<span class="sd">        :return: A list containing the results. Actual results are under the </span>
<span class="sd">          result_object component as dicts</span>
<span class="sd">        :rtype: list[sdk.SearchResultValueObjectObject]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">check_result_type</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
        
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">remove_nones</span><span class="p">(</span><span class="n">query</span> <span class="o">=</span><span class="n">query</span><span class="p">,</span>
                                 <span class="n">taxon</span> <span class="o">=</span> <span class="n">taxon</span><span class="p">,</span>
                                 <span class="n">platform</span> <span class="o">=</span> <span class="n">platform</span><span class="p">,</span>
                                 <span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">,</span>
                                 <span class="n">result_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">result_type</span><span class="p">],</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># df = ps.process_search(response.data,result_type)</span>
        
        <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span></div>

    
    <span class="c1"># taxa/{taxon}/genes/{gene}/locations----</span>
    <span class="c1"># unimplemented, redundant with get_gene_locations</span>

    <span class="c1"># taxa ----</span>
<div class="viewcode-block" id="GemmaPy.get_taxa">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">get_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all taxa within Gemma</span>
<span class="sd">        </span>
<span class="sd">        :param **kwargs: Additional arguments to raw.get_taxa</span>
<span class="sd">        :return: A DataFrame including the names, IDs and database information</span>
<span class="sd">          about the taxons</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">response</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">get_taxa</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">process_taxon</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">taxon_name</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">]</span></div>

        
        
    
    <span class="c1"># taxa/{taxa}, get_taxa_by_ids -----</span>
    <span class="c1"># implemented, hardly needed with 3 taxa  </span>



<span class="c1"># Below are &quot;Convenience&quot; (combination) functions</span>

    <span class="c1"># set_gemma_user is not needed since it&#39;s wrapped in the GemmaPy class</span>
    <span class="c1"># get_platform_annotations is the default get_platform_annotations</span>
    

<div class="viewcode-block" id="GemmaPy.make_design">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.make_design">[docs]</a>
    <span class="k">def</span> <span class="nf">make_design</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">samples</span><span class="p">:</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">meta_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using on the output of get_dataset_samples, this function creates a</span>
<span class="sd">        simplified design table, granting one column to each experimental variable</span>


<span class="sd">        :param samples: An output from get_dataset_samples.</span>
<span class="sd">        :type samples: DataFrame</span>
<span class="sd">        :param meta_type: Type of metadata to include in the output. &quot;text&quot;,</span>
<span class="sd">          &quot;uri&quot; or &quot;both&quot;, defaults to &#39;text&#39;</span>
<span class="sd">        :type meta_type: str, optional</span>
<span class="sd">        :return: A DataFrame including the design table for the dataset</span>
<span class="sd">        :rtype: DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="n">categories</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x</span><span class="p">[[</span><span class="s2">&quot;factor_ID&quot;</span><span class="p">,</span><span class="s2">&quot;factor_category&quot;</span><span class="p">,</span><span class="s2">&quot;factor_category_URI&quot;</span><span class="p">]]</span> 
                                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">samples</span><span class="o">.</span><span class="n">sample_factor_values</span><span class="p">],</span>
                  <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        
        
        <span class="k">def</span> <span class="nf">get_val_uri</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span> 
                              <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">factor_ID</span><span class="o">==</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">value_URI</span><span class="p">])</span> 
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">samples</span><span class="o">.</span><span class="n">sample_factor_values</span><span class="p">]</span>
        
        <span class="n">factor_URIs</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_val_uri</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">categories</span><span class="o">.</span><span class="n">factor_ID</span><span class="p">]</span>
        
        <span class="k">def</span> <span class="nf">get_text</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">get_summary</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">summary</span>
                                 <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">summary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> 
                                 <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">factor_ID</span><span class="o">==</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()])</span>
            
            <span class="k">return</span> <span class="p">[</span><span class="n">get_summary</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">samples</span><span class="o">.</span><span class="n">sample_factor_values</span><span class="p">]</span>
            
            
        
        <span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_text</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">categories</span><span class="o">.</span><span class="n">factor_ID</span><span class="p">]</span>
        
        
        <span class="k">if</span> <span class="n">meta_type</span> <span class="o">==</span><span class="s1">&#39;text&#39;</span><span class="p">:</span>
            <span class="n">design_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">categories</span><span class="o">.</span><span class="n">factor_category</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">text</span>
                <span class="p">})</span>
        <span class="k">elif</span> <span class="n">meta_type</span> <span class="o">==</span> <span class="s1">&#39;uri&#39;</span><span class="p">:</span>
            <span class="n">design_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">categories</span><span class="o">.</span><span class="n">factor_category_URI</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">factor_URIs</span>
                <span class="p">})</span>
        <span class="k">elif</span> <span class="n">meta_type</span> <span class="o">==</span><span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">design_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[[</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">factor_URIs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span> 
                               <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">categories</span><span class="o">.</span><span class="n">factor_category</span> 
                          <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">categories</span><span class="o">.</span><span class="n">factor_category_URI</span><span class="p">]</span>
                <span class="p">})</span>
            
        <span class="n">design_frame</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">column</span> <span class="o">=</span> <span class="s2">&quot;factor_values&quot;</span><span class="p">,</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">sample_factor_values</span><span class="p">)</span>
        <span class="n">design_frame</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">sample_name</span>
        
        <span class="k">return</span> <span class="n">design_frame</span></div>

        
        
    
    <span class="k">def</span> <span class="nf">__subset_factor_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">factor_values</span><span class="p">,</span>
                               <span class="n">differential_expressions</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                               <span class="n">result_set</span><span class="p">,</span>
                               <span class="n">contrast</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">factor_values</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">differential_expressions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">differential_expressions</span><span class="p">[</span><span class="n">differential_expressions</span><span class="o">.</span><span class="n">result_ID</span> <span class="o">==</span> 
                                     <span class="n">result_set</span><span class="p">]</span><span class="o">.</span><span class="n">subset_factor</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="c1"># result set should have the same subset for all contrasts</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">subset_ids</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ID</span>
                
                <span class="n">in_subset</span> <span class="o">=</span> <span class="p">[</span><span class="nb">any</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">list_in_list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="n">subset_ids</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">factor_values</span><span class="p">]</span>
                
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="ow">and</span> <span class="n">in_subset</span>
            
            <span class="k">if</span> <span class="n">contrast</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="n">differential_expressions</span><span class="p">[</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">differential_expressions</span><span class="o">.</span><span class="n">result_ID</span> <span class="o">==</span> <span class="n">result_set</span><span class="p">)</span> <span class="ow">and</span> 
                    <span class="nb">list</span><span class="p">(</span><span class="n">differential_expressions</span><span class="o">.</span><span class="n">contrast_ID</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">contrast</span><span class="p">))]</span>
                
                <span class="n">baseline_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">break_list</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">baseline_factors</span><span class="p">])))</span>
                <span class="n">baseline_factor_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">break_list</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">factor_ID</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">baseline_factors</span><span class="p">])))</span>
                
                <span class="n">contrast_id</span> <span class="o">=</span>  <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">break_list</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">experimental_factors</span><span class="p">])))</span>
                <span class="n">contrast_factor_id</span> <span class="o">=</span>  <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">break_list</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">factor_ID</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">experimental_factors</span><span class="p">])))</span>
                
                <span class="n">contrast_id</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">match_by</span><span class="p">(</span><span class="n">contrast_id</span><span class="p">,</span><span class="n">baseline_factor_id</span><span class="p">,</span> <span class="n">contrast_factor_id</span><span class="p">)</span>
                
                <span class="k">def</span> <span class="nf">in_con</span><span class="p">(</span><span class="n">factor_value</span><span class="p">):</span>
                    <span class="n">cond1</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">list_in_list</span><span class="p">(</span><span class="n">contrast_id</span><span class="p">,</span> <span class="n">factor_value</span><span class="o">.</span><span class="n">ID</span><span class="p">))</span> <span class="ow">or</span> \
                            <span class="nb">all</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">list_in_list</span><span class="p">(</span><span class="n">baseline_id</span><span class="p">,</span><span class="n">factor_value</span><span class="o">.</span><span class="n">ID</span><span class="p">))</span>                   
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contrast_id</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">contrast_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">factor_value</span><span class="o">.</span><span class="n">ID</span> <span class="ow">and</span> \
                                    <span class="n">baseline_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">factor_value</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="p">(</span><span class="n">contrast_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">factor_value</span><span class="o">.</span><span class="n">ID</span> <span class="ow">and</span> \
                                       <span class="n">baseline_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">factor_value</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
                        
                        <span class="n">cond1</span> <span class="o">=</span> <span class="n">cond1</span> <span class="ow">or</span> <span class="n">cond2</span>
                    
                    <span class="k">return</span> <span class="n">cond1</span>
                        
                <span class="n">in_contrast</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_con</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">factor_values</span><span class="p">]</span>
                
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="ow">and</span> <span class="n">in_contrast</span>
        
        <span class="k">return</span> <span class="n">out</span>
        


<div class="viewcode-block" id="GemmaPy.get_dataset_object">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_dataset_object">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dataset_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">],</span>
                           <span class="n">genes</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">keep_non_specific</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">consolidate</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">result_sets</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">contrasts</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">meta_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span><span class="p">,</span>
                           <span class="n">output_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;anndata&#39;</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">:</span><span class="nb">dict</span><span class="o">|</span><span class="n">AnnData</span><span class="p">]:</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a data structure including all relevant data related to</span>
<span class="sd">        gene expression in a dataset. Either returns an anndata object or </span>
<span class="sd">        a dictionary with all the needed fields.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :param datasets: Numerical dataset identifier</span>
<span class="sd">          dataset short names</span>
<span class="sd">        :type datasets: List[str|int]</span>
<span class="sd">        :param genes: An ncbi gene identifier an, </span>
<span class="sd">          ensembl gene identifier which typically starts with ensg or an </span>
<span class="sd">          official gene symbol approved by hgnc, defaults to None</span>
<span class="sd">        :type genes: Optional[List[str|int]], optional</span>
<span class="sd">        :param keep_non_specific: If True, results from </span>
<span class="sd">          probesets that are not specific to the gene will also be returned,</span>
<span class="sd">          defaults to False</span>
<span class="sd">        :type keep_non_specific: TYPE, optional</span>
<span class="sd">        :param consolidate: DESCRIPTION, An option for gene expression level consolidation. </span>
<span class="sd">          If empty, will return every probe for the genes. &quot;pickmax&quot; to pick </span>
<span class="sd">          the probe with the highest expression, &quot;pickvar&quot; to pick the prove </span>
<span class="sd">          with the highest variance and &quot;average&quot; for returning the average </span>
<span class="sd">          expression to None</span>
<span class="sd">        :type consolidate: Optional[str], optional</span>
<span class="sd">        :param result_sets: Result set IDs of the a </span>
<span class="sd">          differential expression analysis. If provided, the output will only </span>
<span class="sd">          include the samples from the subset used in the result set ID. Must </span>
<span class="sd">          be the same length as datasets, defaults to None</span>
<span class="sd">        :type result_sets: Optional[List[int]], optional</span>
<span class="sd">        :param contrasts: Contrast IDs of a differential </span>
<span class="sd">          expression contrast. Need result_sets to be defined to work. If </span>
<span class="sd">          provided, the output will only include samples relevant to the &#39;</span>
<span class="sd">          specific contrats. Must be the same length as datasets.</span>
<span class="sd">        :param str meta_type: How should the metadata information should be </span>
<span class="sd">          included. Can be &quot;text&quot;, &quot;uri&quot; or &quot;both&quot;. &quot;text&quot; and &quot;uri&quot; options, defaults to None</span>
<span class="sd">        :type contrasts: Optional[List[str]], optional</span>
<span class="sd">        :param meta_type: How should the metadata information should be </span>
<span class="sd">          included. Can be &quot;text&quot;, &quot;uri&quot; or &quot;both&quot;. &quot;text&quot; and &quot;uri&quot; options, defaults to &#39;text&#39;</span>
<span class="sd">        :type meta_type: str, optional</span>
<span class="sd">        :param output_type: Type of the returned object. &quot;anndata&quot; for an </span>
<span class="sd">          AnnData object and &quot;dict&quot; for a dictionary populated with DataFrames,</span>
<span class="sd">          defaults to &#39;anndata&#39;</span>
<span class="sd">        :type output_type: str, optional</span>
<span class="sd">        :param **kwargs: DESCRIPTION</span>
<span class="sd">        :type **kwargs: TYPE</span>
<span class="sd">        :raises ValueError: DESCRIPTION</span>
<span class="sd">        :return: A dictionary containing AnnData objects or nested dictionaries</span>
<span class="sd">          that contain expression and sample metada of the requested experiments</span>
<span class="sd">        :rtype: dict[int:dict|AnnData]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        

        
        

        
        <span class="k">if</span> <span class="n">output_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;anndata&quot;</span><span class="p">,</span><span class="s2">&quot;tidy&quot;</span><span class="p">,</span><span class="s2">&quot;dict&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please enter a valid output_type. anndata for&#39;</span>
                             <span class="s1">&#39;&quot;anndata&quot; objects, &quot;tidy&quot; for long form pandas&#39;</span>
                             <span class="s1">&#39;DataFrames, &quot;dict&quot; for dictionaries with separate&#39;</span>
                             <span class="s1">&#39;expression and metadata fields&#39;</span>
                              <span class="p">)</span>
            
        <span class="n">unique_sets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">datasets</span><span class="p">))</span>
        
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_samples</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_sets</span><span class="p">}</span>
        
        
        <span class="k">if</span> <span class="n">genes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">get_exp</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_processed_expression</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_non_specific</span><span class="p">:</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span><span class="o">~</span><span class="n">exp</span><span class="o">.</span><span class="n">GeneSymbol</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">,</span><span class="n">regex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">na</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)]</span>
                
                <span class="k">if</span> <span class="n">consolidate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">consolidate</span> <span class="o">==</span><span class="s1">&#39;pickmax&#39;</span><span class="p">:</span>
                    <span class="n">mean_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">sample_name</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">mean_exp</span><span class="p">,</span><span class="n">decreasing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))]</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span><span class="o">~</span><span class="n">exp</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="s1">&#39;GeneSymbol&#39;</span><span class="p">)]</span>
                <span class="k">elif</span> <span class="n">consolidate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">consolidate</span> <span class="o">==</span> <span class="s1">&#39;pickvar&#39;</span><span class="p">:</span>
                    <span class="n">exp_var</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">sample_name</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">exp_var</span><span class="p">,</span><span class="n">decreasing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))]</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span><span class="o">~</span><span class="n">exp</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="s1">&#39;GeneSymbol&#39;</span><span class="p">)]</span>
                <span class="k">elif</span> <span class="n">consolidate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">consolidate</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
                    <span class="n">dups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span>
                            <span class="n">exp</span><span class="p">[</span><span class="n">exp</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="s2">&quot;GeneSymbol&quot;</span><span class="p">)][</span><span class="s2">&quot;GeneSymbol&quot;</span><span class="p">]</span>
                            <span class="p">))</span>
                        <span class="p">)</span>
                    
                    <span class="k">def</span> <span class="nf">get_mean</span><span class="p">(</span><span class="n">dup</span><span class="p">):</span>
                        <span class="n">dup_subset</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span><span class="n">exp</span><span class="o">.</span><span class="n">GeneSymbol</span> <span class="o">==</span> <span class="n">dup</span><span class="p">]</span>
                        <span class="n">dup_mean</span> <span class="o">=</span>  <span class="n">exp</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">sample_name</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">probe</span> <span class="o">=</span> <span class="s2">&quot;Averaged from &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dup_subset</span><span class="o">.</span><span class="n">Probe</span><span class="p">)</span>
                        
                        <span class="n">gene_info</span> <span class="o">=</span> <span class="n">dup_subset</span><span class="o">.</span>\
                            <span class="n">loc</span><span class="p">[:,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                    <span class="n">sub</span><span class="o">.</span><span class="n">list_in_list</span><span class="p">(</span>
                                        <span class="n">dup_subset</span><span class="o">.</span><span class="n">columns</span><span class="p">,[</span><span class="s2">&quot;Probe&quot;</span><span class="p">]</span> <span class="o">+</span>\
                                            <span class="nb">list</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">sample_name</span><span class="p">))))]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span>\
                                <span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
                        
                        <span class="n">probe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                            <span class="s2">&quot;Probe&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">probe</span><span class="p">]})</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">dup_mean</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
                        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">probe</span><span class="p">,</span><span class="n">gene_info</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">),</span><span class="n">data</span><span class="p">],</span>
                                         <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                    
                    <span class="n">dup_means</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_mean</span><span class="p">(</span><span class="n">dup</span><span class="p">)</span> <span class="k">for</span> <span class="n">dup</span> <span class="ow">in</span> <span class="n">dups</span><span class="p">]</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">exp</span><span class="p">[</span><span class="o">~</span><span class="n">exp</span><span class="o">.</span><span class="n">GeneSymbol</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dups</span><span class="p">)]]</span> <span class="o">+</span> <span class="n">dup_means</span><span class="p">,</span> 
                                    <span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">exp</span>
            <span class="c1">#get_exp</span>
            
            <span class="n">expression</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">get_exp</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_sets</span><span class="p">}</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span>\
                <span class="n">get_dataset_expression_for_genes</span><span class="p">(</span><span class="n">unique_sets</span><span class="p">,</span>
                                                 <span class="n">genes</span> <span class="o">=</span> <span class="n">genes</span><span class="p">,</span>
                                                 <span class="n">keep_non_specific</span> <span class="o">=</span> <span class="n">keep_non_specific</span><span class="p">,</span>
                                                 <span class="n">consolidate</span> <span class="o">=</span> <span class="n">consolidate</span><span class="p">)</span>
        
        <span class="n">designs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">make_design</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datasets_by_ids</span><span class="p">(</span><span class="n">unique_sets</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">pack_data</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">packed_info</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;design&quot;</span><span class="p">:</span><span class="n">designs</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="n">expression</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="s2">&quot;dat&quot;</span><span class="p">:</span> <span class="n">dat</span><span class="p">[(</span><span class="n">dat</span><span class="o">.</span><span class="n">experiment_ID</span> <span class="o">==</span> <span class="n">dataset</span><span class="p">)</span> <span class="o">|</span> \
                           <span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">experiment_short_name</span> <span class="o">==</span> <span class="n">dataset</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
                <span class="s2">&quot;result_set&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;contrasts&quot;</span><span class="p">:</span> <span class="kc">None</span>
                <span class="p">}</span>
            
            
            <span class="k">if</span> <span class="n">result_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;result_set&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">contrasts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;contrasts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contrasts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># reordering to match expression/metadata no longer necesarry</span>
            
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_differential_expression_analyses</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">result_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gene_info</span> <span class="o">=</span> <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">]</span><span class="o">.</span>\
                    <span class="n">columns</span><span class="p">[[</span><span class="ow">not</span> <span class="n">x</span> 
                             <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sub</span><span class="o">.</span><span class="n">list_in_list</span><span class="p">(</span><span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                                                       <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)]]</span>
                
                <span class="n">cons</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">contrasts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">contrasts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="n">relevant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__subset_factor_values</span><span class="p">(</span><span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span><span class="o">.</span>\
                                                       <span class="n">factor_values</span><span class="p">,</span>
                                                       <span class="n">diff</span><span class="p">,</span>
                                                       <span class="n">result_sets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                       <span class="n">cons</span><span class="p">)</span>
                <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">][</span><span class="n">relevant</span><span class="p">]</span>
                <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">][</span><span class="n">gene_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packed_info</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
                
                    
            <span class="k">return</span> <span class="n">packed_info</span>
        
        
        
        <span class="c1"># packed_data = [pack_data(i) for i in range(len(datasets))]</span>
        <span class="n">packed_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">))]</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment_ID</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">packed_data</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">result_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">result_sets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">))]</span>
            <span class="k">if</span> <span class="n">contrasts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">contrasts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">))]</span> 
        
        <span class="n">packed_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">packed_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">))}</span>
        
        
        
        <span class="k">if</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s1">&#39;anndata&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">make_anndata</span><span class="p">(</span><span class="n">pack</span><span class="p">):</span>
                <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">][</span><span class="s1">&#39;Probe&#39;</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span> 
                    <span class="n">gene_data</span> <span class="o">=</span> <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">][[</span><span class="s1">&#39;GeneSymbol&#39;</span><span class="p">,</span> <span class="s1">&#39;NCBIid&#39;</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: One or more gene descriptions are missing in Expression table&quot;</span><span class="p">)</span>
                    <span class="n">gene_data</span> <span class="o">=</span> <span class="kc">None</span>
                
                <span class="n">mda</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;abstract&#39;</span><span class="p">:</span> <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment_description</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;url&#39;</span><span class="p">:</span> <span class="s1">&#39;https://gemma.msl.ubc.ca/expressionExperiment/showExpressionExperiment.html?id=&#39;</span><span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment_ID</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="s1">&#39;database&#39;</span><span class="p">:</span> <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment_database</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;accesion&#39;</span><span class="p">:</span>  <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment_accession</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;GemmaQualityScore&quot;</span><span class="p">:</span>  <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">geeq_q_score</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;GemmaSuitabilityScore&quot;</span><span class="p">:</span>  <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">geeq_s_score</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;taxon&quot;</span><span class="p">:</span>  <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">taxon_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">}</span>
                
                <span class="n">exp</span> <span class="o">=</span> <span class="n">pack</span><span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">][</span><span class="n">pack</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
                <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">gene_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gene_data</span><span class="p">)</span>
                    
                
                <span class="n">adata</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pack</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">])</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">uns</span> <span class="o">=</span> <span class="n">mda</span>
                <span class="k">return</span> <span class="n">adata</span>
            <span class="c1"># make_anndata</span>
            
            
            <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">make_anndata</span><span class="p">(</span><span class="n">packed_data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">packed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s1">&#39;dict&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">packed_data</span>
        <span class="k">elif</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s2">&quot;tidy&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="GemmaPy.get_differential_expression_values">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_differential_expression_values">[docs]</a>
    <span class="k">def</span> <span class="nf">get_differential_expression_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                           <span class="n">dataset</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                           <span class="n">result_sets</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                           <span class="n">readable_contrasts</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the differential expression resultSet(s) associated with the dataset.</span>
<span class="sd">        If there is more than one resultSet, use get_result_sets() to see the options</span>
<span class="sd">        and get the ID you want. Alternatively, you can query the resultSet directly</span>
<span class="sd">        if you know its ID beforehand.</span>
<span class="sd">        </span>
<span class="sd">        In Gemma each result set corresponds to the estimated effects </span>
<span class="sd">        associated with a single factor in the design, and each can have </span>
<span class="sd">        multiple contrasts (for each level compared to baseline). Thus a </span>
<span class="sd">        dataset with a 2x3 factorial design will have two result sets, one of </span>
<span class="sd">        which will have one contrast, and one having two contrasts.</span>
<span class="sd">        </span>
<span class="sd">        The methodology for differential expression is explained in `Curation </span>
<span class="sd">        of over 10000 transcriptomic studies to enable data reuse &lt;https://doi.org/10.1093/database/baab006&gt;`_.</span>
<span class="sd">        Briefly, differential expression analysis is performed on the dataset</span>
<span class="sd">        based on the annotated experimental design with up two three potentially</span>
<span class="sd">        nested factors. Gemma attempts to automatically assign baseline conditions</span>
<span class="sd">        for each factor. In the absence of a clear control condition, a baseline </span>
<span class="sd">        is arbitrarily selected. A generalized linear model with empirical Bayes</span>
<span class="sd">        shrinkage of t-statistics is fit to the data for each platform element </span>
<span class="sd">        (probe/gene) using an implementation of the limma algorithm. For </span>
<span class="sd">        RNA-seq data, we use weighted regression, applying the voom algorithm</span>
<span class="sd">        to compute weights from the mean–variance relationship of the data. </span>
<span class="sd">        Contrasts of each condition are then computed compared to the selected </span>
<span class="sd">        baseline. In some situations, Gemma will split the data into subsets for</span>
<span class="sd">        analysis. A typical such situation is when a ‘batch’ factor is present </span>
<span class="sd">        and confounded with another factor, the subsets being determined by the</span>
<span class="sd">        levels of the confounding factor.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :param dataset: A dataset identifier, defaults to None</span>
<span class="sd">        :type dataset: Optional[str|int], optional</span>
<span class="sd">        :param result_sets: result set identifiers. If a dataset</span>
<span class="sd">          is not provided, all result sets will be downloaded. If it is provided</span>
<span class="sd">          it will only be used to ensure all result sets belong to the dataset, defaults to None</span>
<span class="sd">        :type result_sets: Optional[List[str|int]], optional</span>
<span class="sd">        :param readable_contrasts: If False (default), the returned columns</span>
<span class="sd">          will use internal constrasts IDs as names. Details about the contrasts can be</span>
<span class="sd">          accessed using get_dataset_differential_expression_analyses(). If True IDs</span>
<span class="sd">          will be replaced with human readable contrast information, defaults to False</span>
<span class="sd">        :type readable_contrasts: bool, optional</span>
<span class="sd">        :param **kwargs: </span>
<span class="sd">        :type **kwargs: TYPE</span>
<span class="sd">        :raises ValueError: Will return a value error if neither result_sets nor a dataset</span>
<span class="sd">          is provided</span>
<span class="sd">        :return: A list of data frames with differential expression values per result set.</span>
<span class="sd">        :rtype: List[DataFrame]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diffs</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_differential_expression_analyses</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            <span class="n">rss</span> <span class="o">=</span> <span class="n">diffs</span><span class="o">.</span><span class="n">result_ID</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">list_in_list</span><span class="p">(</span><span class="n">result_sets</span><span class="p">,</span> <span class="n">rss</span><span class="p">)):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The queried resultSet is not derived from this dataset. &#39;</span> 
                              <span class="s1">&#39;Check the available resultSets with &quot;get_result_sets()&quot; &#39;</span>
                              <span class="s1">&#39;or query without the dataset parameter.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">elif</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diffs</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_differential_expression_analyses</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            <span class="n">result_sets</span> <span class="o">=</span> <span class="n">diffs</span><span class="o">.</span><span class="n">result_ID</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You must specify a dataset or result_sets&#39;</span><span class="p">)</span>
            
        <span class="n">rss</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">readable_contrasts</span><span class="p">:</span>
            <span class="n">all_factors</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_result_sets</span><span class="p">(</span><span class="n">result_sets</span> <span class="o">=</span> <span class="n">result_sets</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">rs</span> <span class="ow">in</span> <span class="n">result_sets</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_result_set</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">readable_contrasts</span><span class="p">:</span>
                <span class="n">factors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">all_factors</span><span class="p">[</span><span class="n">all_factors</span><span class="o">.</span><span class="n">result_ID</span> <span class="o">==</span> <span class="n">rs</span><span class="p">]</span><span class="o">.</span><span class="n">experimental_factors</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;log2fc&#39;</span><span class="p">,</span><span class="s1">&#39;logFoldChange&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">factors</span><span class="o">.</span><span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="n">factors</span><span class="o">.</span><span class="n">summary</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">cols</span>
            <span class="n">rss</span><span class="p">[</span><span class="n">rs</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="n">rss</span></div>

            

    <span class="c1"># get_taxa is moved to base. only removes the nameless rat now</span>

    <span class="c1"># gemma_call unimplemented, not needed    </span>

<div class="viewcode-block" id="GemmaPy.get_all_pages">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_all_pages">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_pages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fun</span><span class="p">:</span><span class="n">Callable</span><span class="p">,</span><span class="n">step_size</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="o">|</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A convenience function to allow easy iteration over paginated outputs.</span>
<span class="sd">        If the function returns a DataFrame output will be merged by the rows,</span>
<span class="sd">        if the function returns a list (eg. &#39;raw&#39; functions) a concatanated list</span>
<span class="sd">        will be returned</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :param fun: A callable from gemmapy with offset and limit</span>
<span class="sd">          functions</span>
<span class="sd">        :type fun: Callable</span>
<span class="sd">        :param step_size: Size of individual calls to the server. 100 is </span>
<span class="sd">          the maximum value and the default.</span>
<span class="sd">        :type step_size: int, optional</span>
<span class="sd">        :param **kwargs: arguments for the callable fun</span>
<span class="sd">        :return: A DataFrame or a list containing all the output depending on </span>
<span class="sd">          output of the callable</span>
<span class="sd">        :rtype: list|DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>        
        <span class="n">poke_call</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">limit</span> <span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">poke_call</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">poke_call</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;total_elements&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">poke_call</span><span class="o">.</span><span class="n">total_elements</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="n">step_size</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">limit</span> <span class="o">=</span> <span class="n">step_size</span><span class="p">,</span><span class="n">offset</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">poke_call</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">ignore_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sub</span><span class="o">.</span><span class="n">break_list</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">])</span></div>

        

    
<div class="viewcode-block" id="GemmaPy.filter_properties">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.filter_properties">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;DataFrame&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">dict</span><span class="o">|</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some functions such as get_datasets and get_platforms include a filter</span>
<span class="sd">        argument that allows creation of more complex queries. This function </span>
<span class="sd">        returns a list of supported properties to be used in those filters</span>
<span class="sd">        </span>
<span class="sd">        :param output_type: Type to return. &quot;DataFrame&quot; or &quot;dict&quot;, defaults to &#39;DataFrame&#39;</span>
<span class="sd">        :type output_type: str, optional</span>
<span class="sd">        :return: DataFrame or dict containing supported properties and their data types</span>
<span class="sd">        :rtype: dict|DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">api_client</span><span class="o">.</span><span class="n">rest_client</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s2">&quot;https://gemma.msl.ubc.ca/rest/v2/openapi.json&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">urllib3_response</span>
        <span class="n">api_file</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        
        <span class="n">dataset_filter</span> <span class="o">=</span> <span class="n">api_file</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">][</span><span class="s2">&quot;schemas&quot;</span><span class="p">][</span><span class="s2">&quot;FilterArgExpressionExperiment&quot;</span><span class="p">][</span><span class="s2">&quot;x-gemma-filterable-properties&quot;</span><span class="p">]</span>
        
        <span class="n">platform_filter</span> <span class="o">=</span> <span class="n">api_file</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">][</span><span class="s2">&quot;schemas&quot;</span><span class="p">][</span><span class="s2">&quot;FilterArgArrayDesign&quot;</span><span class="p">][</span><span class="s2">&quot;x-gemma-filterable-properties&quot;</span><span class="p">]</span>
        
        <span class="n">result_set_filter</span> <span class="o">=</span> <span class="n">api_file</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">][</span><span class="s2">&quot;schemas&quot;</span><span class="p">][</span><span class="s2">&quot;FilterArgExpressionAnalysisResultSet&quot;</span><span class="p">][</span><span class="s2">&quot;x-gemma-filterable-properties&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s1">&#39;DataFrame&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;dataset&quot;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">dataset_filter</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">dataset_filter</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">dataset_filter</span><span class="p">,</span><span class="s1">&#39;description&#39;</span><span class="p">)</span>
                    <span class="p">}),</span>
                <span class="s2">&quot;platform&quot;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">platform_filter</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">platform_filter</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">platform_filter</span><span class="p">,</span><span class="s1">&#39;description&#39;</span><span class="p">)</span>
                    <span class="p">}),</span>
                <span class="s2">&quot;result_set&quot;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">result_set_filter</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">result_set_filter</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">),</span>
                    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="n">field_in_list</span><span class="p">(</span><span class="n">result_set_filter</span><span class="p">,</span><span class="s1">&#39;description&#39;</span><span class="p">)</span>
                    <span class="p">})</span>
                <span class="p">}</span>
        <span class="k">elif</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s1">&#39;dict&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;dataset&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">],</span>
                                              <span class="s2">&quot;description&quot;</span><span class="p">:</span><span class="n">sub</span><span class="o">.</span><span class="n">access_field</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;description&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataset_filter</span><span class="p">},</span>
                <span class="s1">&#39;platform&#39;</span><span class="p">:{</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">],</span>
                                              <span class="s2">&quot;description&quot;</span><span class="p">:</span><span class="n">sub</span><span class="o">.</span><span class="n">access_field</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;description&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">platform_filter</span><span class="p">},</span>
                <span class="s1">&#39;result_set&#39;</span><span class="p">:{</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">],</span>
                                              <span class="s2">&quot;description&quot;</span><span class="p">:</span><span class="n">sub</span><span class="o">.</span><span class="n">access_field</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;description&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result_set_filter</span><span class="p">}</span>
                
                <span class="p">}</span></div>

            
        
    
<div class="viewcode-block" id="GemmaPy.get_child_terms">
<a class="viewcode-back" href="../../api.html#gemmapy.GemmaPy.get_child_terms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_child_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">terms</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When querying for ontology terms, Gemma propagates these terms to </span>
<span class="sd">        include any datasets with their child terms in the results. This </span>
<span class="sd">        function returns these children for any number of terms, including all </span>
<span class="sd">        children and the terms itself in the output vector</span>
<span class="sd">        </span>
<span class="sd">        :param terms: A list of ontology terms</span>
<span class="sd">        :type terms: List[str]</span>
<span class="sd">        :return: An array containing descendends of the annotation terms, </span>
<span class="sd">        including the terms themselves</span>
<span class="sd">        :rtype: List[str]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datasets</span><span class="p">(</span><span class="n">uris</span><span class="o">=</span><span class="n">terms</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;http.*?(?=,|\))&#39;</span><span class="p">,</span><span class="n">output</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">])</span></div>
</div>

    
    <span class="c1"># update_results currenty unimplemented and not really essential</span>


<span class="c1"># Tests</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># dv temp</span>
    <span class="kn">import</span> <span class="nn">http.client</span>
    <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="o">.</span><span class="n">debuglevel</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># put 5 to debug</span>

    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

    <span class="n">api_instance</span> <span class="o">=</span> <span class="n">GemmaPy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_dataset_annotations_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing get_dataset_annotations function:&#39;</span><span class="p">)</span>
        <span class="n">api_response</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_dataset_annotations</span><span class="p">(</span><span class="s2">&quot;GSE46416&quot;</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">api_response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search_datasets_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing search_datasets function:&#39;</span><span class="p">)</span>
        <span class="n">api_response</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">search_datasets</span><span class="p">([</span><span class="s2">&quot;bipolar&quot;</span><span class="p">],</span> <span class="n">taxon</span><span class="o">=</span><span class="s2">&quot;human&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">api_response</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">geeq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>  <span class="n">d</span><span class="o">.</span><span class="n">geeq</span><span class="o">.</span><span class="n">batch_corrected</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">short_name</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">bio_assay_count</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_datasets_by_ids_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing get_datasets_by_ids function:&#39;</span><span class="p">)</span>
        <span class="n">api_response</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_datasets_by_ids</span><span class="p">([</span><span class="s2">&quot;GSE46416&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">api_response</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">short_name</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search_annotations_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing search_annotations function:&#39;</span><span class="p">)</span>
        <span class="n">api_response</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">search_annotations</span><span class="p">([</span><span class="s2">&quot;GSE46416&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">api_response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataset_object_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing get_dataset_object function:&#39;</span><span class="p">)</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_dataset_object</span><span class="p">(</span><span class="s2">&quot;GSE46416&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Unstructured Info:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="n">l</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Observation metadata:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Vars metadata:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Subsetting the Experiment</span><span class="se">\n</span><span class="s1">Disease levels&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;disease&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Subset: patients during manic phase and controls&#39;</span><span class="p">)</span>
        <span class="n">manic</span><span class="o">=</span><span class="n">adata</span><span class="p">[:,(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;disease&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;reference_subject_role&#39;</span><span class="p">)</span> <span class="o">|</span>
                      <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;disease&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;bipolar_disorder_|_manic_phase_|&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">manic</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">manic</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_result_sets_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing get_result_sets function:&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_result_sets</span><span class="p">(</span><span class="s1">&#39;GSE6711&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_result_set</span><span class="p">(</span><span class="mi">485406</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_differential_expression_values_test</span><span class="p">():</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_differential_expression_values</span><span class="p">(</span><span class="s1">&#39;GSE46416&#39;</span><span class="p">)</span>
        <span class="n">de</span><span class="p">[</span><span class="s1">&#39;diffexpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No&#39;</span>   <span class="c1"># add extra column</span>
        <span class="c1">#de[&#39;diffexpr&#39;][(de[&#39;contrast_bipolar disorder, manic phase_logFoldChange&#39;]&gt;1.0) &amp;</span>
        <span class="c1">#               (de[&#39;contrast_bipolar disorder, manic phase_pvalue&#39;]&lt;0.05)] = &#39;Up&#39;</span>
        <span class="n">de</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">de</span><span class="p">[</span><span class="s1">&#39;contrast_bipolar disorder, manic phase_logFoldChange&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">de</span><span class="p">[</span><span class="s1">&#39;contrast_bipolar disorder, manic phase_pvalue&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span><span class="s1">&#39;diffexpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Up&#39;</span>
        <span class="n">de</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">de</span><span class="p">[</span><span class="s1">&#39;contrast_bipolar disorder, manic phase_logFoldChange&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span>
                       <span class="p">(</span><span class="n">de</span><span class="p">[</span><span class="s1">&#39;contrast_bipolar disorder, manic phase_pvalue&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span><span class="s1">&#39;diffexpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Down&#39;</span>
        <span class="n">de_up</span> <span class="o">=</span> <span class="n">de</span><span class="p">[</span><span class="n">de</span><span class="p">[</span><span class="s1">&#39;diffexpr&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Up&#39;</span><span class="p">]</span>
        <span class="n">de_up</span> <span class="o">=</span> <span class="n">de_up</span><span class="p">[[</span><span class="s1">&#39;Probe&#39;</span><span class="p">,</span><span class="s1">&#39;GeneSymbol&#39;</span><span class="p">,</span> <span class="s1">&#39;contrast_bipolar disorder, manic phase_pvalue&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;contrast_bipolar disorder, manic phase_logFoldChange&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="s1">&#39;contrast_bipolar disorder, manic phase_pvalue&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Upregulated probes&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">option_context</span><span class="p">(</span><span class="s1">&#39;display.max_rows&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;display.max_columns&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">de_up</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>

        <span class="n">de_dn</span> <span class="o">=</span> <span class="n">de</span><span class="p">[</span><span class="n">de</span><span class="p">[</span><span class="s1">&#39;diffexpr&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Down&#39;</span><span class="p">]</span>
        <span class="n">de_dn</span> <span class="o">=</span> <span class="n">de_dn</span><span class="p">[[</span><span class="s1">&#39;Probe&#39;</span><span class="p">,</span><span class="s1">&#39;GeneSymbol&#39;</span><span class="p">,</span> <span class="s1">&#39;contrast_bipolar disorder, manic phase_pvalue&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;contrast_bipolar disorder, manic phase_logFoldChange&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="s1">&#39;contrast_bipolar disorder, manic phase_pvalue&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Downregulated probes&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">option_context</span><span class="p">(</span><span class="s1">&#39;display.max_rows&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;display.max_columns&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">de_dn</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_platform_annotations_test</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing get_platform_annotations function&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">api_instance</span><span class="o">.</span><span class="n">get_platform_annotations</span><span class="p">(</span><span class="s1">&#39;GPL96&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="c1">#print(&quot;Calling&quot;,fname)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="n">func</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">GemmaPy</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, The University of British Columbia.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>